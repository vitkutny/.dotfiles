#!/usr/bin/env sh

# The on-modify event is triggered separately for each task modified. This hook
# script can accept/reject the modification. Processing will continue.

# Input:
# - line of JSON for the original task
# - line of JSON for the modified task, the diff being the modification
read -r original_task
read -r modified_task

IFS=$'\n' # implode/explode by newline handle tags with spaces
task_uuid=$(printf '%s' "$modified_task" | jq -r '.uuid')
original_task_tags=($(printf '%s' "$original_task" | jq -r '.tags[]?'))
modified_task_tags=($(printf '%s' "$modified_task" | jq -r '.tags[]?'))

# add task uuid to tags
original_task_tags+=("_TASK[$task_uuid]")
modified_task_tags+=("_TASK[$task_uuid]")

# add task project to tags
original_task_project=$(printf '%s' "$original_task" | jq -r '.project')
if [ "$original_task_project" != "null" ]; then
	original_task_tags+=("_PROJECT[$original_task_project]")
fi

modified_task_project=$(printf '%s' "$modified_task" | jq -r '.project')
if [ "$modified_task_project" != "null" ]; then
	modified_task_tags+=("_PROJECT[$modified_task_project]")
fi


# inspired by /opt/homebrew/share/doc/timew/ext/on-modify.timewarrior
original_task_start=$(printf '%s' "$original_task" | jq -r '.start')
modified_task_start=$(printf '%s' "$modified_task" | jq -r '.start')
task_started=0

# task started
if [ "$original_task_start" = "null" ] && [ "$modified_task_start" != "null" ]; then
	task_started=1
	active_task_uuids=$(task +ACTIVE rc.context=none rc.verbose=off uuids)

	if ! [ -z "$active_task_uuids" ]; then
		task stop "$active_task_uuids" > /dev/null # only single active task allowed
	fi

	timew start ${modified_task_tags[@]} > /dev/null
# task stopped
elif [ "$original_task_start" != "null" ] && ([ "$modified_task_start" = "null" ] || [ "$(printf '%s' "$modified_task" | jq -r '.end')" != "null" ]); then
	# ensure start is removed when task is deleted in active state
	modified_task="$(printf '%s' "$modified_task" | jq --compact-output 'del(.start)')"
	modified_task_start="null"

	if ! timew stop > /dev/null; then
		# errors if started and stopped in same second
		# The end of a date range must be after the start.
		sleep 1
		timew stop > /dev/null
	fi
fi

# timew retag when tags are changed
if [[ "${original_task_tags[@]}" != "${modified_task_tags[@]}" ]]; then
	timew_ids=$(timew export :all _TASK\["$task_uuid"\] | jq -r 'map("@\(.id)").[]')
	# untag+tag instead of retag allows for tags from timew extensions
	timew untag $timew_ids ${original_task_tags[@]} > /dev/null
	timew tag $timew_ids ${modified_task_tags[@]} > /dev/null
fi

# timew annotate using task description
if [ "$(printf '%s' "$original_task" | jq -r '.description')" != "$(printf '%s' "$modified_task" | jq -r '.description')" ]; then
	timew_ids=$(timew export :all _TASK\["$task_uuid"\] | jq -r 'map("@\(.id)").[]')
	timew annotate $timew_ids "$(printf '%s' "$modified_task" | jq -r '.description')" > /dev/null
elif [ "$task_started" -eq 1 ]; then
	timew annotate @1 "$(printf '%s' "$modified_task" | jq -r '.description')" > /dev/null
fi

printf '%s' $modified_task

